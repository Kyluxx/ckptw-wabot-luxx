"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useMongoAuthState = void 0;
const mongoose_1 = __importDefault(require("mongoose"));
const async_lock_1 = __importDefault(require("async-lock"));
const Utils_1 = require("../Utils");
const auth_utils_1 = require("./auth-utils");
console.log("Running session mongodb");
const fileLock = new async_lock_1.default({ maxPending: Infinity });
const sessionSchema = new mongoose_1.default.Schema({
    _id: { type: String, required: true },
    value: mongoose_1.default.Schema.Types.Mixed,
    createdAt: { type: Date, default: Date.now },
});
const Session = mongoose_1.default.model("Session", sessionSchema);
const serialize = (data) => {
    if (Buffer.isBuffer(data)) {
        return `Buffer:${data.toString("base64")}`;
    }
    else if (Array.isArray(data)) {
        return data.map(item => serialize(item));
    }
    else if (typeof data === "object" && data !== null) {
        const result = {};
        for (const [key, value] of Object.entries(data)) {
            result[key] = serialize(value);
        }
        return result;
    }
    return data;
};
const deserialize = (data) => {
    if (typeof data === "string" && data.startsWith("Buffer:")) {
        return Buffer.from(data.slice(7), "base64");
    }
    else if (Array.isArray(data)) {
        return data.map(item => deserialize(item));
    }
    else if (typeof data === "object" && data !== null) {
        const result = {};
        for (const [key, value] of Object.entries(data)) {
            result[key] = deserialize(value);
        }
        return result;
    }
    return data;
};
let isConnected = false;
const cache = new Map();
const writeQueue = new Map();
const flushWriteQueue = async () => {
    const tasks = Array.from(writeQueue.entries()).map(([id, { data, resolve, reject }]) => fileLock.acquire(id, async () => {
        try {
            await Session.updateOne({ _id: id }, { value: serialize(data), createdAt: new Date() }, { upsert: true }).exec();
            cache.set(id, data);
            resolve();
        }
        catch (err) {
            reject(err);
        }
        finally {
            writeQueue.delete(id);
        }
    }));
    await Promise.allSettled(tasks);
};
const writeData = (data, file) => {
    const id = file.replace(/\//g, "__").replace(/:/g, "-");
    return new Promise((resolve, reject) => {
        writeQueue.set(id, { data, resolve, reject });
        if (writeQueue.size === 1) {
            setImmediate(flushWriteQueue);
        }
    });
};
const readData = async (file) => {
    const id = file.replace(/\//g, "__").replace(/:/g, "-");
    if (cache.has(id)) {
        return cache.get(id);
    }
    try {
        const doc = await fileLock.acquire(id, () => Session.findById(id).exec());
        const data = doc ? deserialize(doc.value) : null;
        if (data) {
            cache.set(id, data);
        }
        return data;
    }
    catch (error) {
        console.error(`Error reading data from ${file}:`, error);
        return null;
    }
};
const removeData = async (file) => {
    const id = file.replace(/\//g, "__").replace(/:/g, "-");
    await fileLock.acquire(id, async () => {
        await Session.deleteOne({ _id: id }).exec();
    });
    cache.delete(id);
};
const clearAll = async () => {
    await Session.deleteMany({});
    cache.clear();
};
const clearKeys = async () => {
    const creds = await readData("creds");
    await Session.deleteMany({ _id: { $ne: "creds" } });
    cache.clear();
    if (creds) {
        cache.set("creds", creds);
    }
};
const useMongoAuthState = async (mongoURI) => {
    if (!isConnected) {
        try {
            await mongoose_1.default.connect(mongoURI);
            isConnected = true;
        }
        catch (error) {
            console.error("MongoDB connection error:", error);
            throw new Error("Failed to connect to MongoDB");
        }
    }
    const creds = (await readData("creds")) || (0, auth_utils_1.initAuthCreds)();
    return {
        state: {
            creds,
            keys: {
                get: async (type, ids) => {
                    const data = {};
                    await Promise.all(ids.map(async (id) => {
                        let value = await readData(`${type}-${id}`);
                        if (value && type === "app-state-sync-key") {
                            value = (0, Utils_1.fromObject)(value);
                        }
                        data[id] = value;
                    }));
                    return data;
                },
                set: async (data) => {
                    const tasks = [];
                    for (const category in data) {
                        for (const id in data[category]) {
                            const value = data[category][id];
                            const file = `${category}-${id}`;
                            tasks.push(value
                                ? writeData(value, file)
                                : removeData(file));
                        }
                    }
                    await Promise.allSettled(tasks);
                }
            }
        },
        saveCreds: async () => writeData(creds, "creds"),
        clearAll,
        clearKeys
    };
};
exports.useMongoAuthState = useMongoAuthState;
